```json
{
    "date":"2023.02.12 3:18",
    "tags": ["BLOG","GOLANG", "channel"],
    "author": "yongxinz"
}
```

如何理解`channel`的死锁

---

计算机组成原理: 死锁的三个必要条件:
- 循环等待
- 资源共享
- 非抢占式

非缓冲通道`channel`特点: 
- 发送端和接收端同时准备好时才能完成发送和接收的动作
- 即发送和接收是同时的
- 即两端任意一边没准备好时, 即会发生阻塞

```golang
ch := make(chan int)
ch <- 1
z := <-ch
```
以上代码流程中, 因为`ch <- 1`这一步发生阻塞, 所以永远不可能走到下一步`z := <-ch`, 导致发生死锁；无论是先发送还是先接收, 只要两者处于同一流程中, 都会因阻塞导致无法走到下一步而死锁(即以上代码中发送和接收的次序调换结果也一样).

解决办法: 使用协程
```golang
ch := make(chan int)
go func() {
    ch <- 1
}
z := <-ch
```
以上代码使用协程将发送端从当前流程中分出, 协程不会阻塞, 程序可以顺利走到`z := <-ch `, 当两端ready的时候完成通道操作.

但如果先操作通道:
```go
ch := make(chan int)
ch <- 1
go func() {
    <-ch
}
```
即会发生死锁, 因为当前流程中, 启动协程`go func...`必须要等待上一步`ch <- 1`通道发送动作完成才能进行, 但因为此时通道接收端没有准备, 导致永远阻塞在这一步而死锁
> (启动协程才能完成通道接收端的准备, 然而接收端不准备好就没法走到启动协程的步骤)

总结: 
- 对于无缓冲通道, 一个流程只能操作发送或接收两者其一
- 操作无缓冲通道的发送或接收时, 要先在另外的流程(启动协程)中准备好接收或发送的动作.





