```json
{
    "date":"2023.02.15 18:00",
    "tags": ["BLOG","PHP","GC"],
    "author": "Letotn"
}
```

什么是垃圾回收: 动态分配存储, 释放程序不再需要的已分配的内存块, 回收内存空间的过程

---

### php 5.3版本之前
php垃圾回收机制在5.3版本之前, 是简单的"引用计数", 即
- 每个内存对象都分配一个计数器, 当内存对象被变量引用时, 计数器+1
- 当变量引用结束之后, (使用unset) 计数器-1
- 当计数器=0时, 表明内存对象没有被变量引用, 程序销毁该内存对象, 垃圾回收完成

且PHP在生命周期结束后, 就会释放该进程/线程所占用的内存

问题: 当两个或以上的内存对象相互引用时(或循环引用), 其计数器无法减到0, 即永远不会被回收, 造成有内存泄露.

### php 5.3版本之后
变量的结构: `zval` 变量容器
- 变量名称
- 变量的值
- `is_ref` bool 标识是否属于引用集合(reference set), 区分变通变量和引用变量
- `refcount` int 引用计数, 表示引指向这个变量容器的符号(symbol)个数

### php 7
引用变量时(使用"&"), php会创建新中间结构体`zend_refence`, 在内嵌了`zval`, 指向原`zval`的value(bool, int, float则直接复制原有值), 并将原`zval`类型修改`IS_REFERENCE`, 

举例:
```php
$a = "ok" // $a -> zend_string
$b = $a;  // $b -> zende_string
$c = &$b; // $c, $b -> zval(type=IS_REFERENCE, refcount=2) -> zend_string
```

循环引用的问题:
```php
$a = [1];
$a[] = &$a;

unset($a);
```
使用`&`操作符之后, 变量a就变成引用类型且引用计数`refcount`=2, 赋值给自己里面的元素, 造成自己引用自己；

`unset `之后, `$a`所在的`zval`类型变成了`IS_UNDEF`, 此时`refcount`引用计数减1但仍大于0, 此时这部分结构体就变成垃圾(不可能再访问到), 不处理则可能造成内存泄露；


### 回收过程
当`refcount`减小后仍大于0, PHP不会马上回收这个值, 而是放入一个缓冲区, 等缓冲区满之后(约10000个值)统一处理；缓冲区只收集两种类型: 数组和对象；

一个变量只能加入一次缓冲区，为了防止重复加入，变量加入后会把 `zend_refcounted_h.gc_info` 置为 `GC_PURPLE`，即标为紫色，后续不会重复插入。

垃圾缓冲区是一个双向链表，等到缓存区满了以后则启动垃圾检查过程：遍历缓冲区，对当前变量的所有成员进行遍历，然后把成员的 `refcount` 减 1 (如果成员还包含子成员则也进行递归遍历，即深度优先遍历)，最后再检查当前变量的引用，如果减为了 0 则为垃圾。

这个算法的原理核心是：垃圾是由于成员引用自身导致的，那么就对所有的成员减一遍引用，如果发现最后变量本身的 `refcount` 变为了 0 则就表明其引用全部来自自身成员，即其他任何地方都不再使用它，那么它就是垃圾，需要被回收掉。反之说明不是垃圾，需要将其从缓冲区移出去。具体的过程如下：

(1) 从缓冲区链表的 `roots` 开始遍历，把当前 value 标为灰色 (`zend_refcounted_h.gc_info` 置为 `GC_GREY`)，然后对当前 value 的成员进行深度优先遍历，把成员 value 的 `refcount` 减 1，并且也标为灰色；

(2) 重复遍历缓冲区链表，检查当前 value 引用是否为 0，为 0 则表示确实是垃圾，把它标为白色 (`GC_WHITE`)，如果不为 0 则排除了引用全部来自自身成员的可能，表示还有外部的引用，并不是垃圾，这时候因为步骤 (1) 对成员进行了 `refcount` 减 1 操作，需要再还原回去，对所有成员进行深度遍历，把成员 `refcount` 加 1，同时标为黑色；

(3) 再次遍历缓冲区链表，将非 `GC_WHITE` 的节点从 `roots` 链表中移出，最终 `roots` 链表中全部为真正的垃圾，最后将这些垃圾清除。
。 

